<h2>Active Record Associations</h2>

<ul>

  <li>
    <p>
      Association w RoR to połączenie między dwoma modelami Active Record. Dlaczego
      potrzebujemy asocjacji między modelami? Ponieważ sprawiają że wiele popularnych
      operacji jest dzięki nim łatwiejszych. Na przykład rozważmy prostą aplikację
      z modelami autora i książki. Każdy autor może mieć wiele książek. Bez
      asocjacji deklaracje modeli wyglądałyby w ten sposób. Załóżmy,  że chcemy
      dodać książkę do istniejącego autora. Należałoby przekazać obiektowi książki
      id konkretnego autora. W przypadku usuwania autora trzeba zadbać również o
      usunięcie jego książek. Z asocjacjami Active Record możemy ominąć te operacje
      przez przekazanie RoR informacji, że modele są połączone. Oto poprawiony
      program klas Author i Book. Dzięki tej zmianie tworzenie książki dla autora
      jest bardzo łatwe. Również łatwiejsze jest usuwanie autora. Więcej informacji
      o asocjacjach znajduje się w dalszej części przewodnika. Są tam również
      różne tricki i porady przydatne podczas działań związanych z asocjacjami
      a także kompletne odnośniki do metod i opcji dla asocjacji w RoR.
    </p>
  </li>

  <li>
    <p>
      RoR posiada 6 typów asocjacji - belongs_to, has_one, has_many, has_many :through,
      has_one :through, has_and_belongs_to_many. Asocjacje są zaimplementowane
      z użyciem wywołań w stylu makro, dzięki czemu można dodawać nowe funkcje
      do modelu w sposób deklaratywny. Na przykład poprzez zadeklarowanie, że
      jeden model belongs_to do innego informuje się o konieczności istnienia
      kluczy głównego i obcego i ich zależności. Dla modelu wygenerowane zostaną
      również różne przydatne funkcje. W pozostałej części poradnika znajdzie się
      informacja o tym jak deklarować i używać różnych form asocjacji. Najpierw
      jednak krótki wstęp i wyjaśnienie sytuacji, w których stosuje się poszczególne
      typy asocjacji. Asocjacja belongs_to ustala relację jeden do jednego z innym
      modelem w ten sposób, że każda instacja modelu należy do jednej instancji
      innego modelu. Na przykład jeżeli w aplikacji są autorzy i książki a każda
      może należeć do dokładnie jednego autora można napisać "belongs_to :author"
      w klasie książki. Asocjacja belongs_to musi używać rzeczownika w liczbie
      pojedynczej. Gdyby użyto formy mnogiej i napisano "Book.create(authors: @author)"
      zostałby wyświetlony błąd mówiący o nieistniejącej stałej Book::Authors.
      Dzieje się tak ponieważ RoR automatycznie wnioskuje nazwę klasy z nazwy
      w asocjacji. Jeżeli nazwa asocjacji jest źle spluralizowana, wywnioskowana
      klasa również będzie błędnie spluralizowana. W migracji można również użyć
      belongs_to, np "t.belongs_to :author". Asocjacja has_one również ustawia
      połączenie jeden do jednego z innym modelem, posiada jednak inną semantykę
      i konsekwencje. Ta asocjacja wskazuje, że każda instacja modelu posiada lub
      zawiera instancję innego modelu. Na przykład jeżeli każdy supplier posiada
      jedno konto można napisać "has_one :account". W zależności od sytuacji, może
      istnieć konieczność stworzenia unikalnego indexu i/lub ograniczeń klucza obcego
      w kolumnie supplier_id, np "t.belongs_to :supplier, index: { unique: true },
      foreign_key: true". Asocjacja has_many wskazuje na połączenie jeden do wielu
      z innym modelem. Ta asocjacja jest często używana po drugiej stronie asocjacji
      belongs_to. Wskazuje, że każda instajca modelu ma zero jub więcej instancji
      innego modelu. Na przykład w aplikacji z autorami i książkami w modelu autora
      można napisać "has_many :books". Nazwa modelu jest tu spluralizowana.
      Asocjacja has_many :through jest często używana do ustawienia relacji
      wiele do wielu. Informuje, że model może być połączony z jednym lub wieloma
      modelami przez trzeci model. Na przykład lekarz i pacjenci mogą umawiać się
      na wizyty. Potrzebne są trzy modele Physician Appointment i Patient. Kolekcja
      join modeli może być obsługiwana przez metody asocjacyjne has_many. Na przykład
      jeśli "physician.patients = patients", powstaną nowe join modele dla nowych
      połączonych obiektów. Jeżeli modele istniejące wcześniej zostały usunięte,
      odpowiadające im wiersze join zostaną również automatycznie usunięte.
      Automatyczne usuwanie join modeli jest bezpośrednie bez wywoływania destroy
      callbacków. Asocjacja has_many :through jest również przydatna do ustawiania
      skrótów przez zagnieżdżone asocjacje has_many. Na przykład jeżeli dokument
      ma wiele sekcji a każda sekcja ma wiele paragrafów lepiej mieć prostą kolekcję
      wszystkich paragrafów w dokumencie. Asocjacja has_one :through ustawia połączenie
      jeden do jednego z innym modelem. Wskazuje, że instancja modelu łączy się z
      jedną instancją innego modelu przez trzeci model. Na przykład jeżeli każdy
      supplier ma jedno konto i każde konto jest połączone z jedną historią konta.
      Asocjacja has_and_belongs_to_many tworzy bezpośrednie połączenie wiele do
      wielu z innym modelem, bez trzeciego modelu. Na przykład jeżeli aplikacja
      posiada assemblies i parts i każdy assembly ma wiele partsów a każdy part
      pojawia się w wielu assemblach. Jeżeli chce się ustawić relację jeden do
      jednego po jednej stronie musi być belongs_to a po drugiej has_one. Skąd
      wiadomo, który model powinien posiadać którą relację? To zależy od tego, w
      której tabeli istnieje klucz obcy. Jej model będzie miał relację belongs_to.
      Należy jednak zastanowić się również nad znaczeniem danych. Relacja has_one
      wskazuje że jedna rzecz należy do innej rzeczy. Na przykład większy sens
      ma supplier posiadający konto niż odwrotnie. Używanie "t.bigint :supplier_id"
      sprawia że nazwa klucza obcego jest oczywista i wyraźna. W obecnej wersji RoR
      można ukryć ten szczegół implementacji używając "t.references :supplier".
      RoR posiada dwie metody deklarowania relacji wiele do wielu między modelami.
      Łatwiejsza z nich to użycie metody has_and_belongs_to_many co tworzy
      bezpośrednie powiązanie. Druga metoda to has_many :through. Asocjacja tworzona
      jest pośrednio przez join model. Jeżeli model relacji jest traktowany jako
      oddzielny rekord należy użyć has_many :through. Jeżeli nie ma potrzeby
      korzystania z modelu relacji, łatwiej będzie użyć has_and_belongs_to_many.
      W tym przypadku konieczne będzie jednak również stworzenie odpowiedniej
      tabeli w bazie danych. Asocjacja has_many :through powinna być użyta jeżeli
      join model potrzebuje walidacji, callbacków lub dodatkowych atrybutów.
      Nieco bardziej zaawansowaną wersją asocjacji są polimorficzne asocjacje.
      Z polimorficznymi asocjacjami model może należeć do więcej niż jednego modelu
      w jednej asocjacji. Na przykład może istnieć model Picture należący do
      modelu Employee lub do modelu Product. W modelu Picture "belongs_to :imageable,
      polymorphic: true", a w modelach Employee i Product "has_many :pictures,
      as: :imageable". Polimorficzne belongs_to to ustawianie interfejsu, który
      może być używany przez jakikolwiek inny model. Z instancji modelu Employee
      można uzyskać kolekcję zdjęć @employee.pictures. Podobnie można użyć
      @product.pictures. Jeżeli istnieje instancja obiektu Picture, można dostać
      się do jego rodzica przez @picture.imageable. Aby to zadziałało konieczne
      jest zadeklarowanie kolumny klucza obcego i kolumny typu w modelu deklarującym
      polimorficzny interfejs, np "t.bigint  :imageable_id, t.string  :imageable_type".
      Migracja może być uproszczona przez użycie formy t.references. Należy napisać
      "t.references :imageable, polymorphic: true". Podczas projektowania modelu
      danych czasami pojawi się model, który powinien mieć relację do samego siebie.
      Na przykład może istnieć potrzeba przechowywania wszystkich pracowników w
      jednym modelu bazy danych z jednoczesną koniecznością śledzenia relacji, np
      między menadżerem a podwładnymi. Ta sytuacja może być modelowana z asocjacjami
      self-joining - "has_many :subordinates, class_name: "Employee",foreign_key:
      "manager_id", "belongs_to :manager, class_name: "Employee", optional: true".
      Z takimi ustawieniami można uzyskać @employee.subordinates i @employee.manager.
      W pliku migracji należy dodać kolumnę referencji do tabeli odpowiadającej
      modelowi Employee - "t.references :manager".
    </p>
  </li>

  <li>
    <p>
      Aby w skuteczny sposób korzystać z asocjacji Active Record dobrze jest
      wiedzieć o kilku rzeczach: kontrolowaniu cachingu, unikaniu kolizji nazw,
      updatowaniu schematu, kontrolowaniu zasięgu asocjacji i o asocjacjach
      dwukierunkowych. Wszystkie metody asocjacyjne są zbudowane wokół cachingu,
      który przechowuje wynik ostatnich zapytań dla przyszłych potrzeb. Cache
      jest współdzielone nawet między metodami. Na przykład 2 kolejne wywołania
      "author.books, author.books.size, author.books.empty?" będą korzystać z
      cache. Co jeśli trzeba przeładować cache, ponieważ dane mogły zostać
      zmienione przez inną część aplikacji? Wystarczy użyć metody reload, np
      "author.books, author.books.size, author.books.reload.empty?". Podczas
      tworzenia asocjacji nie ma pełnej dowolności wybierania nazw. Ponieważ
      nowa asocjacja to nowa metoda modelu, nie należy używać  nazw wykorzystywanych
      już przez ActiveRecord::Base. Nowa metoda nadpisałaby metodę bazową co
      mogłoby doprowadzić do błędów. Nie należy używać nazw takich jak attributes
      albo connection. Asocjacje są wyjątkowo przydatne, jednak nie są magiczne.
      To użytkownik jest odpowiedzialny za dbanie o dopasowanie schematu bazy
      do asocjacji. Dla asocjacji belongs_to konieczne jest stworzenie kluczy
      obcych a dla has_and_belongs_to_many należy utworzyć odpowiednią tabelę
      join. Jeżeli w klasie Book jest napisane "belongs_to :author", migracja
      tworząca tabelę powinna zawierać "t.references :author" lub jeżeli tabela
      już istnieje "add_reference :books, :author". Jeżeli chce się wymusić
      integralność referencyjną na poziomie bazy danych należy dodać opcję
      "foreign_key: true" do deklaracji kolumny 'reference'. Kolejny typ asocjacji
      has_and_belongs_to_many, wymaga tabeli join. Jeżeli nazwa tabeli nie zostanie
      jawnie przekazana opcji :join_table, Active Record wygeneruje ją automatycznie
      z nazw klas w kolejności leksykalnej. Np, tabela join między modelami author
      i book będzie się nazywała authors_books, ponieważ litera 'a' poprzedza 'b'.
      Pierwszeństwo pomiędzy nazwami modeli jest obliczane z wykorzystaniem
      operatora '<=>' klasy String. Oznacza to, że jeżeli stringi są różnej długości
      i są równe do długości krótszego, dłuższy string będzie miał pierwszeństwo
      przed krótszym. Na przykład mogłoby się wydawać że tabele paper_boxes i
      papers wygenerują tabelę join "papers_paper_boxes" ze względu na długość
      nazwy "paper_boxes". Powstanie jednak tabela "paper_boxes_papers", ponieważ
      '_' jest mniejsze niż 's'. Niezależnie od nazwy, należy ręcznie wygenerować
      tabelę join używając odpowiedniej migracji. Na przykład dla relacji
      "has_and_belongs_to_many :parts" i "has_and_belongs_to_many :assemblies"
      potrzebna jest tabela assemblies_parts. Powinna być ona tabelą bez klucza
      głównego. Przekazana zostaje opcja "id: false", ponieważ tabela nie
      reprezentuje modelu. Jest to wymagane aby asocjacja działała prawidłowo.
      Jeżeli obserwowane są dziwne zachowania w powyższej asocjacji, np zniekształcone
      id modeli lub wyjątki o konfliktach id, możliwe, że popełniony został właśnie
      ten błąd. Do stworzenia tabeli join można też użyć metody create_join_table.
      Domyślnie asocjacje szukają obiektów jedynie w zasięgu aktualnego modułu.
      Może to być istotne jeżeli modele AR są deklarowane wewnątrz modułu.
      Jeżeli klasy są zadeklarowane w tym samym module asocjacja zadziała, jeżeli
      są w innych - nie. Aby użyć asocjacji z modelami z różnych przestrzeni nazw
      konieczne jest przekazanie pełnej nazwy klasy w deklaracji asocjacji, np
      "class_name: "MyApplication::Billing::Account"" w klasie supplier i
      "class_name: "MyApplication::Business::Supplier"" w klasie account.
      Asocjacje działają dwukierunkowo, co wymaga deklaracji w obu modelach, np
      has_many i belongs_to. AR podejmie próbę automatycznej identyfikacji tych
      modeli opartą na nazwie asocjacji. W ten sposób AR wczyta jedynie jedną
      kopię obiektu klasy Author sprawiając, że aplikacja będzie szybsza i mniej
      narażona na niespójność danych. AR automatycznie identyfikuje większość
      asocjacji ze standardowymi nazwami jednak nie zrobi tego dla asocjacji
      zawierających scope lub jedną z opcji :through :foreign_key. W tym przypadku
      należy ręcznie zadeklarować dwukierunkową asocjację używając opcji :inverse_of.
    </p>
  </li>


  <li>
    <p>
      Sekcja zwiera szczegóły każdego typu asocjacji, ich metody i opcje.
      Metoda belongs_to to relacja jeden do jednego i oznacza że ta klasa
      posiada klucz obcy. Jeżeli klucz obcy posiada inna klasa, nalezy użyć
      has_one. Relacja belongs_to powoduje wygenerowanie 6 metod dla modelu.
      Metody mają nazwy odpowiadające nazwie modelu. Kiedy inicjalizowana jest
      nowa asocjacja has_one lub belongs_to, należy użyć prefiksu "build_"
      aby ją zbudować. Metoda association.build jest używana do relacji has_many
      i has_and_belongs_to_many. Aby ją utworzyć należy skorzystać z prefixu
      create_. Metoda association zwraca powiązany obiekt lub nil. Jeżeli obiekt
      został już wcześniej wczytany, zostanie zwrócona wersja z cache. Aby
      nadpisać to zachowanie należy wywołać #reload_association na obiekcie
      rodzica, np "@author = @book.reload_author". Metoda association= to
      przypisanie obiektu do obiektu. Oznacza to pobranie klucza głównego i
      ustawienie go jako klucza obcego obiektu. Metoda build_association zwraca
      nowy obiekt odpowiedniego typu jednak nie powoduje zapisania go w bazie,
      np "@author = @book.build_author(author_number: 123, author_name: "John Doe")".
      Metoda create_association działa podobnie jak poprzednia z tym że obiekt
      zostanie zapisany w bazie danych. Wersja z wykrzyknikiem generuje błąd
      jeśli obiekt jest nieprawidłowy. Asocjacja belongs_to może zostać modyfikowana
      z użyciem różnych opcji. Jeżeli opcja :autosave jest ustawiona na true, RoR
      zapisze wszystkie załadowane obiekty asocjacji i usunie wszystko obiekty
      zaznaczone do usunięcia za każdym razem kiedy główny obiekt zostanie zapisany.
      Ustawienie autosave na false to nie to samo co brak ustawienia autosave.
      Jeżeli opcja autosave nie jest ustawiona, nowe połączone obiekty będą zapisane
      ale updatowane obiekty nie. Jeżeli nazwa modelu nie może być wywnioskowana
      na podstawie nazwy asocjaciji można użyć opcji class_name. Np jeżeli książka
      należy do autora ale nazwa modelu z autorem to Patron, można napisać
      "belongs_to :author, class_name: "Patron"". Opcja :counter_cache używana jest
      do efektywniejszego wyszukiwania liczby obiektów. Można np napisać w modelu
      Book "belongs_to :author, counter_cache: true". W tym przypadku w modelu
      Author należy dodać kolumnę books_count. Domyślną nazwę kolumny można
      nadpisać podając ją zamiast wartości true - "counter_cache: :count_of_books".
      Opcja :counter_cache powinna być zadeklarowa jedynie po stronie relacji
      belongs_to. Kolumny counter_cache są dodawane do listy atrybutów read-only
      modelu zawierającego poprzez attr_readonly. Opcja :dependent...
    </p>
  </li>

  <li>
    <p>

    </p>
  </li>

</ul>
